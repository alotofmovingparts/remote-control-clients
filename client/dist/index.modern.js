var t,s=new Uint8Array(16);function e(){if(!t&&!(t="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return t(s)}var n=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function i(t){return"string"==typeof t&&n.test(t)}for(var a,c=[],l=0;l<256;++l)c.push((l+256).toString(16).substr(1));function o(t,s,n){var a=(t=t||{}).random||(t.rng||e)();if(a[6]=15&a[6]|64,a[8]=63&a[8]|128,s){n=n||0;for(var l=0;l<16;++l)s[n+l]=a[l];return s}return function(t){var s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,e=(c[t[s+0]]+c[t[s+1]]+c[t[s+2]]+c[t[s+3]]+"-"+c[t[s+4]]+c[t[s+5]]+"-"+c[t[s+6]]+c[t[s+7]]+"-"+c[t[s+8]]+c[t[s+9]]+"-"+c[t[s+10]]+c[t[s+11]]+c[t[s+12]]+c[t[s+13]]+c[t[s+14]]+c[t[s+15]]).toLowerCase();if(!i(e))throw TypeError("Stringified UUID is invalid");return e}(a)}!function(t){t.Connecting="CONNECTING",t.Connected="CONNECTED",t.Disconnected="DISCONNECTED"}(a||(a={}));class r extends EventTarget{constructor(t){super(),this.url=void 0,this.ws=void 0,this.state=void 0,this._callbacks=void 0,this.url=t,this.state=a.Disconnected,this._callbacks={}}connect(t){this.state=a.Connecting,this.ws=new WebSocket(this.url),this.ws.onopen=s=>{var e;const n=o();t&&(this._callbacks[n]=t),null==(e=this.ws)||e.send(JSON.stringify({type:"connect",uuid:n}))},this.ws.onclose=t=>{this.state=a.Disconnected,this.dispatchEvent(new CustomEvent("disconnect"))},this.ws.onmessage=t=>{const s=JSON.parse(t.data);let e;switch(s.type){case"set_response":if(e=s,e.uuid in this._callbacks){const t=this._callbacks[e.uuid];delete this._callbacks[e.uuid],t(null)}break;case"read_response":if(e=s,e.uuid in this._callbacks){const t=this._callbacks[e.uuid];delete this._callbacks[e.uuid];const s=Object.keys(e.values);t(null,s.length>1?e.values:e.values[s[0]])}break;case"clients_response":if(e=s,e.uuid in this._callbacks){const t=this._callbacks[e.uuid];delete this._callbacks[e.uuid],t(null,e.clients)}break;case"connect_response":if(e=s,this.state=a.Connected,e.uuid in this._callbacks){const t=this._callbacks[e.uuid];delete this._callbacks[e.uuid],t(null,e.initialValues,e.clients)}this.dispatchEvent(new CustomEvent("connect",{detail:e}));break;case"update":e=s,this.dispatchEvent(new CustomEvent("update",{detail:e}));break;case"error":if(e=s,e.uuid&&e.uuid in this._callbacks){const t=this._callbacks[e.uuid];delete this._callbacks[e.uuid],t(new Error(e.message))}this.dispatchEvent(new CustomEvent("error",{detail:e}))}},this.ws.onerror=t=>{const s={type:"error",message:String(t)};this.dispatchEvent(new CustomEvent("error",{detail:s}))}}set(t,s,e){var n;const i=o();e&&(this._callbacks[i]=e),null==(n=this.ws)||n.send(JSON.stringify({type:"set",values:{[t]:s},uuid:i}))}read(t,s){var e;const n=o();s&&(this._callbacks[n]=s),null==(e=this.ws)||e.send(JSON.stringify({type:"read",names:t?[t]:[],uuid:n}))}clients(t){var s;const e=o();t&&(this._callbacks[e]=t),null==(s=this.ws)||s.send(JSON.stringify({type:"clients",uuid:e}))}disconnect(){var t;null==(t=this.ws)||t.close()}}export{r as default};
//# sourceMappingURL=index.modern.js.map
